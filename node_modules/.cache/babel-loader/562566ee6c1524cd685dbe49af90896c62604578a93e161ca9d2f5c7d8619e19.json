{"ast":null,"code":"import { supabase } from './supabase';\n// Audit Trail Service for comprehensive logging\nexport class AuditTrailService {\n  // Initialize audit trail for user session\n  static initialize(userId, sessionId) {\n    this.currentUserId = userId;\n    this.sessionId = sessionId;\n\n    // Log session start\n    this.logUserActivity('login', 'User logged into the system', {\n      session_id: sessionId,\n      login_timestamp: new Date().toISOString()\n    });\n\n    // Set up page visibility change listener\n    this.setupPageVisibilityListener();\n\n    // Set up beforeunload listener for logout tracking\n    this.setupBeforeUnloadListener();\n  }\n\n  // Core audit logging method\n  static async logAuditEvent(auditData) {\n    // In development mode, just log to console instead of database\n    if (process.env.NODE_ENV === 'development') {\n      console.log('🔍 Audit Event:', auditData.action_type, '-', auditData.action_details);\n      return true;\n    }\n    try {\n      const auditEntry = {\n        ...auditData,\n        user_id: this.currentUserId || auditData.user_id,\n        session_id: this.sessionId || auditData.session_id,\n        ip_address: await this.getClientIP(),\n        user_agent: navigator.userAgent,\n        page_url: window.location.href,\n        created_at: new Date().toISOString(),\n        metadata: {\n          ...auditData.metadata,\n          timestamp: Date.now(),\n          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n          screen_resolution: `${window.screen.width}x${window.screen.height}`,\n          viewport_size: `${window.innerWidth}x${window.innerHeight}`\n        }\n      };\n      const {\n        error\n      } = await supabase.from('audit_logs').insert(auditEntry);\n      if (error) {\n        // Check if it's a database setup issue\n        if (error.message.includes('relation') && error.message.includes('does not exist')) {\n          console.warn('⚠️ Database tables not set up yet. Please run the schema from database/schema.sql');\n        } else {\n          console.warn('⚠️ Audit logging error:', error.message);\n        }\n        // Don't fail the application if audit logging fails\n        return true;\n      }\n      return true;\n    } catch (error) {\n      console.error('Audit trail error:', error);\n      return false;\n    }\n  }\n\n  // User Activity Logging\n  static async logUserActivity(actionType, actionDetails, metadata) {\n    return this.logAuditEvent({\n      action_type: actionType,\n      action_details: actionDetails,\n      metadata\n    });\n  }\n\n  // Navigation Tracking\n  static async logNavigation(fromPath, toPath, metadata) {\n    return this.logAuditEvent({\n      action_type: 'navigate',\n      action_details: `Navigation from ${fromPath} to ${toPath}`,\n      metadata: {\n        ...metadata,\n        from_path: fromPath,\n        to_path: toPath,\n        navigation_type: 'route_change'\n      }\n    });\n  }\n\n  // Request-specific Logging\n  static async logRequestAction(requestId, actionType, actionDetails, previousStage, newStage, previousStatus, newStatus, amountInvolved, metadata) {\n    return this.logAuditEvent({\n      request_id: requestId,\n      action_type: actionType,\n      action_details: actionDetails,\n      previous_stage: previousStage,\n      new_stage: newStage,\n      previous_status: previousStatus,\n      new_status: newStatus,\n      amount_involved: amountInvolved,\n      metadata\n    });\n  }\n\n  // Data Access Logging\n  static async logDataAccess(dataType, accessType, recordId, metadata) {\n    // Map access types to valid audit action types\n    const actionTypeMap = {\n      'view': 'view',\n      'create': 'create',\n      'update': 'update',\n      'delete': 'update' // Map delete to update since it's not in our enum\n    };\n    return this.logAuditEvent({\n      action_type: actionTypeMap[accessType] || 'view',\n      action_details: `${accessType.toUpperCase()} access to ${dataType}${recordId ? ` (ID: ${recordId})` : ''}`,\n      metadata: {\n        ...metadata,\n        data_type: dataType,\n        access_type: accessType,\n        record_id: recordId\n      }\n    });\n  }\n\n  // Security Event Logging\n  static async logSecurityEvent(eventType, details, metadata) {\n    return this.logAuditEvent({\n      action_type: 'view',\n      // Using 'view' as base type for security events\n      action_details: `SECURITY EVENT: ${eventType} - ${details}`,\n      metadata: {\n        ...metadata,\n        security_event: true,\n        event_type: eventType,\n        severity: 'high'\n      }\n    });\n  }\n\n  // Error Logging\n  static async logError(errorType, errorMessage, stackTrace, metadata) {\n    return this.logAuditEvent({\n      action_type: 'view',\n      // Using 'view' as base type for error events\n      action_details: `ERROR: ${errorType} - ${errorMessage}`,\n      metadata: {\n        ...metadata,\n        error_event: true,\n        error_type: errorType,\n        error_message: errorMessage,\n        stack_trace: stackTrace,\n        severity: 'error'\n      }\n    });\n  }\n\n  // Performance Logging\n  static async logPerformanceMetric(metricName, value, unit, metadata) {\n    return this.logAuditEvent({\n      action_type: 'view',\n      // Using 'view' as base type for performance events\n      action_details: `PERFORMANCE: ${metricName} = ${value}${unit}`,\n      metadata: {\n        ...metadata,\n        performance_metric: true,\n        metric_name: metricName,\n        metric_value: value,\n        metric_unit: unit\n      }\n    });\n  }\n\n  // Session Management\n  static async logSessionEnd(reason) {\n    const result = await this.logUserActivity('logout', `Session ended: ${reason}`, {\n      session_end_reason: reason,\n      session_duration: this.getSessionDuration()\n    });\n\n    // Clear session data\n    this.currentUserId = null;\n    this.sessionId = null;\n    return result;\n  }\n\n  // Utility Methods\n  static async getClientIP() {\n    try {\n      // In production, this would be handled by the backend\n      // For now, we'll use a placeholder\n      return 'client-ip-placeholder';\n    } catch {\n      return 'unknown';\n    }\n  }\n  static getSessionDuration() {\n    // Calculate session duration in minutes\n    const sessionStart = localStorage.getItem('adfd-session-start');\n    if (sessionStart) {\n      return Math.floor((Date.now() - parseInt(sessionStart)) / 60000);\n    }\n    return 0;\n  }\n  static setupPageVisibilityListener() {\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden) {\n        this.logUserActivity('view', 'Page became hidden/inactive');\n      } else {\n        this.logUserActivity('view', 'Page became visible/active');\n      }\n    });\n  }\n  static setupBeforeUnloadListener() {\n    window.addEventListener('beforeunload', () => {\n      // Use sendBeacon for reliable logging on page unload\n      if (navigator.sendBeacon && this.currentUserId) {\n        const auditData = {\n          user_id: this.currentUserId,\n          action_type: 'logout',\n          action_details: 'Page unload detected',\n          session_id: this.sessionId,\n          created_at: new Date().toISOString()\n        };\n        try {\n          navigator.sendBeacon(`${process.env.REACT_APP_SUPABASE_URL}/rest/v1/audit_logs`, JSON.stringify(auditData));\n        } catch (error) {\n          // Silently fail on page unload\n          console.warn('Failed to send beacon on page unload');\n        }\n      }\n    });\n  }\n\n  // Batch Logging for Performance\n\n  static queueAuditEvent(auditData) {\n    this.auditQueue.push(auditData);\n    if (this.batchTimeout) {\n      clearTimeout(this.batchTimeout);\n    }\n    this.batchTimeout = setTimeout(() => {\n      this.flushAuditQueue();\n    }, 5000); // Flush every 5 seconds\n  }\n  static async flushAuditQueue() {\n    if (this.auditQueue.length === 0) return;\n    const batch = [...this.auditQueue];\n    this.auditQueue = [];\n    try {\n      const {\n        error\n      } = await supabase.from('audit_logs').insert(batch);\n      if (error) {\n        console.error('Batch audit logging error:', error);\n        // Re-queue failed items\n        this.auditQueue.unshift(...batch);\n      }\n    } catch (error) {\n      console.error('Batch audit flush error:', error);\n      // Re-queue failed items\n      this.auditQueue.unshift(...batch);\n    }\n  }\n}\nAuditTrailService.sessionId = null;\nAuditTrailService.currentUserId = null;\nAuditTrailService.auditQueue = [];\nAuditTrailService.batchTimeout = null;","map":{"version":3,"names":["supabase","AuditTrailService","initialize","userId","sessionId","currentUserId","logUserActivity","session_id","login_timestamp","Date","toISOString","setupPageVisibilityListener","setupBeforeUnloadListener","logAuditEvent","auditData","process","env","NODE_ENV","console","log","action_type","action_details","auditEntry","user_id","ip_address","getClientIP","user_agent","navigator","userAgent","page_url","window","location","href","created_at","metadata","timestamp","now","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","screen_resolution","screen","width","height","viewport_size","innerWidth","innerHeight","error","from","insert","message","includes","warn","actionType","actionDetails","logNavigation","fromPath","toPath","from_path","to_path","navigation_type","logRequestAction","requestId","previousStage","newStage","previousStatus","newStatus","amountInvolved","request_id","previous_stage","new_stage","previous_status","new_status","amount_involved","logDataAccess","dataType","accessType","recordId","actionTypeMap","toUpperCase","data_type","access_type","record_id","logSecurityEvent","eventType","details","security_event","event_type","severity","logError","errorType","errorMessage","stackTrace","error_event","error_type","error_message","stack_trace","logPerformanceMetric","metricName","value","unit","performance_metric","metric_name","metric_value","metric_unit","logSessionEnd","reason","result","session_end_reason","session_duration","getSessionDuration","sessionStart","localStorage","getItem","Math","floor","parseInt","document","addEventListener","hidden","sendBeacon","REACT_APP_SUPABASE_URL","JSON","stringify","queueAuditEvent","auditQueue","push","batchTimeout","clearTimeout","setTimeout","flushAuditQueue","length","batch","unshift"],"sources":["C:/Users/Ousmane/Documents/TrackingSystem/ADFD_Tracking_System/src/lib/auditTrail.ts"],"sourcesContent":["import { supabase } from './supabase';\r\nimport { AuditLog } from './database';\r\n\r\n// Audit Trail Service for comprehensive logging\r\nexport class AuditTrailService {\r\n  private static sessionId: string | null = null;\r\n  private static currentUserId: string | null = null;\r\n\r\n  // Initialize audit trail for user session\r\n  static initialize(userId: string, sessionId: string) {\r\n    this.currentUserId = userId;\r\n    this.sessionId = sessionId;\r\n    \r\n    // Log session start\r\n    this.logUserActivity('login', 'User logged into the system', {\r\n      session_id: sessionId,\r\n      login_timestamp: new Date().toISOString()\r\n    });\r\n\r\n    // Set up page visibility change listener\r\n    this.setupPageVisibilityListener();\r\n    \r\n    // Set up beforeunload listener for logout tracking\r\n    this.setupBeforeUnloadListener();\r\n  }\r\n\r\n  // Core audit logging method\r\n  static async logAuditEvent(auditData: Partial<AuditLog>): Promise<boolean> {\r\n    // In development mode, just log to console instead of database\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.log('🔍 Audit Event:', auditData.action_type, '-', auditData.action_details);\r\n      return true;\r\n    }\r\n\r\n    try {\r\n      const auditEntry: Partial<AuditLog> = {\r\n        ...auditData,\r\n        user_id: this.currentUserId || auditData.user_id,\r\n        session_id: this.sessionId || auditData.session_id,\r\n        ip_address: await this.getClientIP(),\r\n        user_agent: navigator.userAgent,\r\n        page_url: window.location.href,\r\n        created_at: new Date().toISOString(),\r\n        metadata: {\r\n          ...auditData.metadata,\r\n          timestamp: Date.now(),\r\n          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\r\n          screen_resolution: `${window.screen.width}x${window.screen.height}`,\r\n          viewport_size: `${window.innerWidth}x${window.innerHeight}`\r\n        }\r\n      };\r\n\r\n      const { error } = await supabase\r\n        .from('audit_logs')\r\n        .insert(auditEntry);\r\n\r\n      if (error) {\r\n        // Check if it's a database setup issue\r\n        if (error.message.includes('relation') && error.message.includes('does not exist')) {\r\n          console.warn('⚠️ Database tables not set up yet. Please run the schema from database/schema.sql');\r\n        } else {\r\n          console.warn('⚠️ Audit logging error:', error.message);\r\n        }\r\n        // Don't fail the application if audit logging fails\r\n        return true;\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Audit trail error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // User Activity Logging\r\n  static async logUserActivity(\r\n    actionType: AuditLog['action_type'], \r\n    actionDetails: string, \r\n    metadata?: Record<string, any>\r\n  ): Promise<boolean> {\r\n    return this.logAuditEvent({\r\n      action_type: actionType,\r\n      action_details: actionDetails,\r\n      metadata\r\n    });\r\n  }\r\n\r\n  // Navigation Tracking\r\n  static async logNavigation(fromPath: string, toPath: string, metadata?: Record<string, any>): Promise<boolean> {\r\n    return this.logAuditEvent({\r\n      action_type: 'navigate',\r\n      action_details: `Navigation from ${fromPath} to ${toPath}`,\r\n      metadata: {\r\n        ...metadata,\r\n        from_path: fromPath,\r\n        to_path: toPath,\r\n        navigation_type: 'route_change'\r\n      }\r\n    });\r\n  }\r\n\r\n  // Request-specific Logging\r\n  static async logRequestAction(\r\n    requestId: number,\r\n    actionType: AuditLog['action_type'],\r\n    actionDetails: string,\r\n    previousStage?: string,\r\n    newStage?: string,\r\n    previousStatus?: string,\r\n    newStatus?: string,\r\n    amountInvolved?: number,\r\n    metadata?: Record<string, any>\r\n  ): Promise<boolean> {\r\n    return this.logAuditEvent({\r\n      request_id: requestId,\r\n      action_type: actionType,\r\n      action_details: actionDetails,\r\n      previous_stage: previousStage,\r\n      new_stage: newStage,\r\n      previous_status: previousStatus,\r\n      new_status: newStatus,\r\n      amount_involved: amountInvolved,\r\n      metadata\r\n    });\r\n  }\r\n\r\n  // Data Access Logging\r\n  static async logDataAccess(\r\n    dataType: string,\r\n    accessType: 'view' | 'create' | 'update' | 'delete',\r\n    recordId?: string | number,\r\n    metadata?: Record<string, any>\r\n  ): Promise<boolean> {\r\n    // Map access types to valid audit action types\r\n    const actionTypeMap: Record<string, AuditLog['action_type']> = {\r\n      'view': 'view',\r\n      'create': 'create',\r\n      'update': 'update',\r\n      'delete': 'update' // Map delete to update since it's not in our enum\r\n    };\r\n\r\n    return this.logAuditEvent({\r\n      action_type: actionTypeMap[accessType] || 'view',\r\n      action_details: `${accessType.toUpperCase()} access to ${dataType}${recordId ? ` (ID: ${recordId})` : ''}`,\r\n      metadata: {\r\n        ...metadata,\r\n        data_type: dataType,\r\n        access_type: accessType,\r\n        record_id: recordId\r\n      }\r\n    });\r\n  }\r\n\r\n  // Security Event Logging\r\n  static async logSecurityEvent(\r\n    eventType: 'unauthorized_access' | 'permission_denied' | 'suspicious_activity' | 'password_change',\r\n    details: string,\r\n    metadata?: Record<string, any>\r\n  ): Promise<boolean> {\r\n    return this.logAuditEvent({\r\n      action_type: 'view', // Using 'view' as base type for security events\r\n      action_details: `SECURITY EVENT: ${eventType} - ${details}`,\r\n      metadata: {\r\n        ...metadata,\r\n        security_event: true,\r\n        event_type: eventType,\r\n        severity: 'high'\r\n      }\r\n    });\r\n  }\r\n\r\n  // Error Logging\r\n  static async logError(\r\n    errorType: string,\r\n    errorMessage: string,\r\n    stackTrace?: string,\r\n    metadata?: Record<string, any>\r\n  ): Promise<boolean> {\r\n    return this.logAuditEvent({\r\n      action_type: 'view', // Using 'view' as base type for error events\r\n      action_details: `ERROR: ${errorType} - ${errorMessage}`,\r\n      metadata: {\r\n        ...metadata,\r\n        error_event: true,\r\n        error_type: errorType,\r\n        error_message: errorMessage,\r\n        stack_trace: stackTrace,\r\n        severity: 'error'\r\n      }\r\n    });\r\n  }\r\n\r\n  // Performance Logging\r\n  static async logPerformanceMetric(\r\n    metricName: string,\r\n    value: number,\r\n    unit: string,\r\n    metadata?: Record<string, any>\r\n  ): Promise<boolean> {\r\n    return this.logAuditEvent({\r\n      action_type: 'view', // Using 'view' as base type for performance events\r\n      action_details: `PERFORMANCE: ${metricName} = ${value}${unit}`,\r\n      metadata: {\r\n        ...metadata,\r\n        performance_metric: true,\r\n        metric_name: metricName,\r\n        metric_value: value,\r\n        metric_unit: unit\r\n      }\r\n    });\r\n  }\r\n\r\n  // Session Management\r\n  static async logSessionEnd(reason: 'logout' | 'timeout' | 'forced'): Promise<boolean> {\r\n    const result = await this.logUserActivity('logout', `Session ended: ${reason}`, {\r\n      session_end_reason: reason,\r\n      session_duration: this.getSessionDuration()\r\n    });\r\n\r\n    // Clear session data\r\n    this.currentUserId = null;\r\n    this.sessionId = null;\r\n\r\n    return result;\r\n  }\r\n\r\n  // Utility Methods\r\n  private static async getClientIP(): Promise<string> {\r\n    try {\r\n      // In production, this would be handled by the backend\r\n      // For now, we'll use a placeholder\r\n      return 'client-ip-placeholder';\r\n    } catch {\r\n      return 'unknown';\r\n    }\r\n  }\r\n\r\n  private static getSessionDuration(): number {\r\n    // Calculate session duration in minutes\r\n    const sessionStart = localStorage.getItem('adfd-session-start');\r\n    if (sessionStart) {\r\n      return Math.floor((Date.now() - parseInt(sessionStart)) / 60000);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  private static setupPageVisibilityListener(): void {\r\n    document.addEventListener('visibilitychange', () => {\r\n      if (document.hidden) {\r\n        this.logUserActivity('view', 'Page became hidden/inactive');\r\n      } else {\r\n        this.logUserActivity('view', 'Page became visible/active');\r\n      }\r\n    });\r\n  }\r\n\r\n  private static setupBeforeUnloadListener(): void {\r\n    window.addEventListener('beforeunload', () => {\r\n      // Use sendBeacon for reliable logging on page unload\r\n      if (navigator.sendBeacon && this.currentUserId) {\r\n        const auditData = {\r\n          user_id: this.currentUserId,\r\n          action_type: 'logout' as const,\r\n          action_details: 'Page unload detected',\r\n          session_id: this.sessionId,\r\n          created_at: new Date().toISOString()\r\n        };\r\n\r\n        try {\r\n          navigator.sendBeacon(\r\n            `${process.env.REACT_APP_SUPABASE_URL}/rest/v1/audit_logs`,\r\n            JSON.stringify(auditData)\r\n          );\r\n        } catch (error) {\r\n          // Silently fail on page unload\r\n          console.warn('Failed to send beacon on page unload');\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  // Batch Logging for Performance\r\n  private static auditQueue: Partial<AuditLog>[] = [];\r\n  private static batchTimeout: NodeJS.Timeout | null = null;\r\n\r\n  static queueAuditEvent(auditData: Partial<AuditLog>): void {\r\n    this.auditQueue.push(auditData);\r\n\r\n    if (this.batchTimeout) {\r\n      clearTimeout(this.batchTimeout);\r\n    }\r\n\r\n    this.batchTimeout = setTimeout(() => {\r\n      this.flushAuditQueue();\r\n    }, 5000); // Flush every 5 seconds\r\n  }\r\n\r\n  private static async flushAuditQueue(): Promise<void> {\r\n    if (this.auditQueue.length === 0) return;\r\n\r\n    const batch = [...this.auditQueue];\r\n    this.auditQueue = [];\r\n\r\n    try {\r\n      const { error } = await supabase\r\n        .from('audit_logs')\r\n        .insert(batch);\r\n\r\n      if (error) {\r\n        console.error('Batch audit logging error:', error);\r\n        // Re-queue failed items\r\n        this.auditQueue.unshift(...batch);\r\n      }\r\n    } catch (error) {\r\n      console.error('Batch audit flush error:', error);\r\n      // Re-queue failed items\r\n      this.auditQueue.unshift(...batch);\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}